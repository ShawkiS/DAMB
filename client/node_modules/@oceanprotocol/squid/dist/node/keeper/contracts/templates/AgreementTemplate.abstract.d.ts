import ContractBase from "../ContractBase";
import { Condition, ConditionState } from "../conditions/Condition.abstract";
import { DDO } from "../../../ddo/DDO";
import { ServiceAgreementTemplate } from "../../../ddo/ServiceAgreementTemplate";
import { InstantiableConfig } from "../../../Instantiable.abstract";
export declare abstract class AgreementTemplate extends ContractBase {
    static getInstance(config: InstantiableConfig, conditionName: string, templateClass: any): Promise<AgreementTemplate & any>;
    protected constructor(contractName: string);
    createAgreement(agreementId: string, did: string, conditionIds: string[], timeLocks: number[], timeOuts: number[], ...args: any[]): any;
    getConditionTypes(): Promise<string[]>;
    getConditions(): Promise<Condition[]>;
    abstract getAgreementIdsFromDDO(agreementId: string, ddo: DDO, consumer: string, from?: string): Promise<string[]>;
    abstract createAgreementFromDDO(agreementId: string, ddo: DDO, consumer: string, from?: string): Promise<boolean>;
    abstract getServiceAgreementTemplate(): Promise<ServiceAgreementTemplate>;
    getServiceAgreementTemplateConditions(): Promise<import("../../../ddo/ServiceAgreementTemplate").ServiceAgreementTemplateCondition[]>;
    getServiceAgreementTemplateConditionByRef(ref: string): Promise<Condition>;
    getServiceAgreementTemplateDependencies(): Promise<{
        [condition: string]: string[];
    }>;
    getAgreementStatus(agreementId: string): Promise<{
        [condition: string]: {
            condition: string;
            contractName: string;
            state: ConditionState;
            blocked: boolean;
            blockedBy: string[];
        };
    } | false>;
    printAgreementStatus(agreementId: string): Promise<void>;
    getAgreementCreatedEvent(agreementId: string): import("../../ContractEvent").ContractEvent;
}
