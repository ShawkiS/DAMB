{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\ASUS\\\\Desktop\\\\DAMB-Marketplace\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\ASUS\\\\Desktop\\\\DAMB-Marketplace\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"C:\\\\Users\\\\ASUS\\\\Desktop\\\\DAMB-Marketplace\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport { useEffect, useState } from 'react';\nimport ipfsClient from 'ipfs-http-client';\nimport { parseHTML } from '../utils';\nvar ipfs = null;\nvar ipfsVersion = '';\nexport default function useIpfsApi(config) {\n  var _useState = useState(Boolean(ipfs)),\n      _useState2 = _slicedToArray(_useState, 2),\n      isIpfsReady = _useState2[0],\n      setIpfsReady = _useState2[1];\n\n  var _useState3 = useState(''),\n      _useState4 = _slicedToArray(_useState3, 2),\n      ipfsError = _useState4[0],\n      setIpfsError = _useState4[1];\n\n  useEffect(function () {\n    function initIpfs() {\n      return _initIpfs.apply(this, arguments);\n    }\n\n    function _initIpfs() {\n      _initIpfs = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var version, message, htmlData;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(ipfs !== null)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 2:\n                _context.next = 4;\n                return ipfsClient(config);\n\n              case 4:\n                ipfs = _context.sent;\n                _context.prev = 5;\n                _context.next = 8;\n                return ipfs.version();\n\n              case 8:\n                version = _context.sent;\n                ipfsVersion = version.version;\n                _context.next = 19;\n                break;\n\n              case 12:\n                _context.prev = 12;\n                _context.t0 = _context[\"catch\"](5);\n                message = _context.t0.message;\n\n                if (!_context.t0.status) {\n                  htmlData = parseHTML(_context.t0);\n                  message = htmlData.item(0);\n                  message = message.textContent;\n                }\n\n                setIpfsError(\"IPFS connection error: \".concat(message));\n                setIpfsReady(false);\n                return _context.abrupt(\"return\");\n\n              case 19:\n                _context.t1 = setIpfsReady;\n                _context.t2 = Boolean;\n                _context.next = 23;\n                return ipfs.id();\n\n              case 23:\n                _context.t3 = _context.sent;\n                _context.t4 = (0, _context.t2)(_context.t3);\n                (0, _context.t1)(_context.t4);\n\n              case 26:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[5, 12]]);\n      }));\n      return _initIpfs.apply(this, arguments);\n    }\n\n    initIpfs();\n  }, [config]);\n  useEffect(function () {\n    // just like componentWillUnmount()\n    return function cleanup() {\n      if (ipfs) {\n        setIpfsReady(false);\n        ipfs = null;\n        ipfsVersion = '';\n        setIpfsError('');\n      }\n    };\n  }, []);\n  return {\n    ipfs: ipfs,\n    ipfsVersion: ipfsVersion,\n    isIpfsReady: isIpfsReady,\n    ipfsError: ipfsError\n  };\n}","map":{"version":3,"sources":["C:\\Users\\ASUS\\Desktop\\DAMB-Marketplace\\client\\src\\hooks\\use-ipfs-api.tsx"],"names":["useEffect","useState","ipfsClient","parseHTML","ipfs","ipfsVersion","useIpfsApi","config","Boolean","isIpfsReady","setIpfsReady","ipfsError","setIpfsError","initIpfs","version","message","status","htmlData","item","textContent","id","cleanup"],"mappings":";;;AAAA,SAASA,SAAT,EAAoBC,QAApB,QAAoC,OAApC;AACA,OAAOC,UAAP,MAAuB,kBAAvB;AACA,SAASC,SAAT,QAA0B,UAA1B;AAEA,IAAIC,IAAS,GAAG,IAAhB;AACA,IAAIC,WAAW,GAAG,EAAlB;AAQA,eAAe,SAASC,UAAT,CAAoBC,MAApB,EAAwC;AAAA,kBACjBN,QAAQ,CAACO,OAAO,CAACJ,IAAD,CAAR,CADS;AAAA;AAAA,MAC9CK,WAD8C;AAAA,MACjCC,YADiC;;AAAA,mBAEnBT,QAAQ,CAAC,EAAD,CAFW;AAAA;AAAA,MAE9CU,SAF8C;AAAA,MAEnCC,YAFmC;;AAIrDZ,EAAAA,SAAS,CAAC,YAAM;AAAA,aACCa,QADD;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA,+BACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBACMT,IAAI,KAAK,IADf;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA,uBAGeF,UAAU,CAACK,MAAD,CAHzB;;AAAA;AAGEH,gBAAAA,IAHF;AAAA;AAAA;AAAA,uBAM0BA,IAAI,CAACU,OAAL,EAN1B;;AAAA;AAMUA,gBAAAA,OANV;AAOIT,gBAAAA,WAAW,GAAGS,OAAO,CAACA,OAAtB;AAPJ;AAAA;;AAAA;AAAA;AAAA;AASUC,gBAAAA,OATV,eASUA,OATV;;AAWI,oBAAI,CAAC,YAAMC,MAAX,EAAmB;AACXC,kBAAAA,QADW,GACAd,SAAS,aADT;AAEjBY,kBAAAA,OAAO,GAAGE,QAAQ,CAACC,IAAT,CAAc,CAAd,CAAV;AACAH,kBAAAA,OAAO,GAAGA,OAAO,CAACI,WAAlB;AACD;;AAEDP,gBAAAA,YAAY,kCAA2BG,OAA3B,EAAZ;AACAL,gBAAAA,YAAY,CAAC,KAAD,CAAZ;AAlBJ;;AAAA;AAAA,8BAqBEA,YArBF;AAAA,8BAqBeF,OArBf;AAAA;AAAA,uBAqB6BJ,IAAI,CAACgB,EAAL,EArB7B;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OADc;AAAA;AAAA;;AAyBdP,IAAAA,QAAQ;AACT,GA1BQ,EA0BN,CAACN,MAAD,CA1BM,CAAT;AA4BAP,EAAAA,SAAS,CAAC,YAAM;AACd;AACA,WAAO,SAASqB,OAAT,GAAmB;AACxB,UAAIjB,IAAJ,EAAU;AACRM,QAAAA,YAAY,CAAC,KAAD,CAAZ;AACAN,QAAAA,IAAI,GAAG,IAAP;AACAC,QAAAA,WAAW,GAAG,EAAd;AACAO,QAAAA,YAAY,CAAC,EAAD,CAAZ;AACD;AACF,KAPD;AAQD,GAVQ,EAUN,EAVM,CAAT;AAYA,SAAO;AAAER,IAAAA,IAAI,EAAJA,IAAF;AAAQC,IAAAA,WAAW,EAAXA,WAAR;AAAqBI,IAAAA,WAAW,EAAXA,WAArB;AAAkCE,IAAAA,SAAS,EAATA;AAAlC,GAAP;AACD","sourcesContent":["import { useEffect, useState } from 'react'\r\nimport ipfsClient from 'ipfs-http-client'\r\nimport { parseHTML } from '../utils'\r\n\r\nlet ipfs: any = null\r\nlet ipfsVersion = ''\r\n\r\nexport interface IpfsConfig {\r\n  protocol: string\r\n  host: string\r\n  port: string\r\n}\r\n\r\nexport default function useIpfsApi(config: IpfsConfig) {\r\n  const [isIpfsReady, setIpfsReady] = useState(Boolean(ipfs))\r\n  const [ipfsError, setIpfsError] = useState('')\r\n\r\n  useEffect(() => {\r\n    async function initIpfs() {\r\n      if (ipfs !== null) return\r\n      // eslint-disable-next-line\r\n      ipfs = await ipfsClient(config)\r\n\r\n      try {\r\n        const version = await ipfs.version()\r\n        ipfsVersion = version.version\r\n      } catch (error) {\r\n        let { message } = error\r\n\r\n        if (!error.status) {\r\n          const htmlData = parseHTML(error)\r\n          message = htmlData.item(0)\r\n          message = message.textContent\r\n        }\r\n\r\n        setIpfsError(`IPFS connection error: ${message}`)\r\n        setIpfsReady(false)\r\n        return\r\n      }\r\n      setIpfsReady(Boolean(await ipfs.id()))\r\n    }\r\n\r\n    initIpfs()\r\n  }, [config])\r\n\r\n  useEffect(() => {\r\n    // just like componentWillUnmount()\r\n    return function cleanup() {\r\n      if (ipfs) {\r\n        setIpfsReady(false)\r\n        ipfs = null\r\n        ipfsVersion = ''\r\n        setIpfsError('')\r\n      }\r\n    }\r\n  }, [])\r\n\r\n  return { ipfs, ipfsVersion, isIpfsReady, ipfsError }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}