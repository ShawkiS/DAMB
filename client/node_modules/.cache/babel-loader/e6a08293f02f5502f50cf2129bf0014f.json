{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\ASUS\\\\Desktop\\\\commons-0.1.0\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _toConsumableArray from \"C:\\\\Users\\\\ASUS\\\\Desktop\\\\commons-0.1.0\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\ASUS\\\\Desktop\\\\commons-0.1.0\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport axios from 'axios';\nexport function formatBytes(a, b) {\n  if (a === 0) return '0 Bytes';\n  var c = 1024;\n  var d = b || 2;\n  var e = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n  var f = Math.floor(Math.log(a) / Math.log(c));\n  return parseFloat((a / Math.pow(c, f)).toFixed(d)) + ' ' + e[f];\n}\n\nvar streamFiles = function streamFiles(ipfs, file) {\n  return new Promise(function (resolve, reject) {\n    var stream = ipfs.addReadableStream({\n      wrapWithDirectory: true // progress: (length: number) => setFileSizeReceived(formatBytes(length, 0))\n\n    });\n    stream.on('data', function (data) {\n      console.log(\"Added \".concat(data.path, \" hash: \").concat(data.hash)); // The last data event will contain the directory hash\n\n      if (data.path === '') resolve(data.hash);\n    });\n    stream.on('error', reject);\n    stream.write(file);\n    stream.end();\n  });\n};\n\nexport function addToIpfs(_x, _x2) {\n  return _addToIpfs.apply(this, arguments);\n}\n\nfunction _addToIpfs() {\n  _addToIpfs = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(files, ipfs) {\n    var file, fileDetails, directoryCid, cid;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            file = _toConsumableArray(files)[0];\n            fileDetails = {\n              path: file.name,\n              content: file\n            };\n            _context.next = 4;\n            return streamFiles(ipfs, fileDetails);\n\n          case 4:\n            directoryCid = _context.sent;\n            cid = \"\".concat(directoryCid, \"/\").concat(file.name);\n            return _context.abrupt(\"return\", cid);\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _addToIpfs.apply(this, arguments);\n}\n\nexport function pingUrl(_x3) {\n  return _pingUrl.apply(this, arguments);\n}\n\nfunction _pingUrl() {\n  _pingUrl = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2(url) {\n    var response;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            _context2.next = 3;\n            return axios(url, {\n              timeout: 5000\n            });\n\n          case 3:\n            response = _context2.sent;\n\n            if (!(!response || response.status !== 200)) {\n              _context2.next = 6;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", false);\n\n          case 6:\n            return _context2.abrupt(\"return\", true);\n\n          case 9:\n            _context2.prev = 9;\n            _context2.t0 = _context2[\"catch\"](0);\n            console.error(_context2.t0.message);\n            return _context2.abrupt(\"return\", false);\n\n          case 13:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[0, 9]]);\n  }));\n  return _pingUrl.apply(this, arguments);\n}\n\nexport function parseHTML(str) {\n  var tmp = document.implementation.createHTMLDocument();\n  tmp.body.innerHTML = str;\n  return tmp.body.children;\n}","map":{"version":3,"sources":["C:\\Users\\ASUS\\Desktop\\commons-0.1.0\\client\\src\\utils.ts"],"names":["axios","formatBytes","a","b","c","d","e","f","Math","floor","log","parseFloat","pow","toFixed","streamFiles","ipfs","file","Promise","resolve","reject","stream","addReadableStream","wrapWithDirectory","on","data","console","path","hash","write","end","addToIpfs","files","fileDetails","name","content","directoryCid","cid","pingUrl","url","timeout","response","status","error","message","parseHTML","str","tmp","document","implementation","createHTMLDocument","body","innerHTML","children"],"mappings":";;;AAAA,OAAOA,KAAP,MAAkB,OAAlB;AAEA,OAAO,SAASC,WAAT,CAAqBC,CAArB,EAAgCC,CAAhC,EAA2C;AAChD,MAAID,CAAC,KAAK,CAAV,EAAa,OAAO,SAAP;AACb,MAAME,CAAC,GAAG,IAAV;AACA,MAAMC,CAAC,GAAGF,CAAC,IAAI,CAAf;AACA,MAAMG,CAAC,GAAG,CAAC,OAAD,EAAU,IAAV,EAAgB,IAAhB,EAAsB,IAAtB,EAA4B,IAA5B,EAAkC,IAAlC,EAAwC,IAAxC,EAA8C,IAA9C,EAAoD,IAApD,CAAV;AACA,MAAMC,CAAC,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,GAAL,CAASR,CAAT,IAAcM,IAAI,CAACE,GAAL,CAASN,CAAT,CAAzB,CAAV;AACA,SAAOO,UAAU,CAAC,CAACT,CAAC,GAAGM,IAAI,CAACI,GAAL,CAASR,CAAT,EAAYG,CAAZ,CAAL,EAAqBM,OAArB,CAA6BR,CAA7B,CAAD,CAAV,GAA8C,GAA9C,GAAoDC,CAAC,CAACC,CAAD,CAA5D;AACD;;AAED,IAAMO,WAAW,GAAG,SAAdA,WAAc,CAACC,IAAD,EAAYC,IAAZ;AAAA,SAClB,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AAC/B,QAAMC,MAAM,GAAGL,IAAI,CAACM,iBAAL,CAAuB;AACpCC,MAAAA,iBAAiB,EAAE,IADiB,CAEpC;;AAFoC,KAAvB,CAAf;AAKAF,IAAAA,MAAM,CAACG,EAAP,CAAU,MAAV,EAAkB,UAACC,IAAD,EAAe;AAC/BC,MAAAA,OAAO,CAACf,GAAR,iBAAqBc,IAAI,CAACE,IAA1B,oBAAwCF,IAAI,CAACG,IAA7C,GAD+B,CAG/B;;AACA,UAAIH,IAAI,CAACE,IAAL,KAAc,EAAlB,EAAsBR,OAAO,CAACM,IAAI,CAACG,IAAN,CAAP;AACvB,KALD;AAOAP,IAAAA,MAAM,CAACG,EAAP,CAAU,OAAV,EAAmBJ,MAAnB;AACAC,IAAAA,MAAM,CAACQ,KAAP,CAAaZ,IAAb;AACAI,IAAAA,MAAM,CAACS,GAAP;AACD,GAhBD,CADkB;AAAA,CAApB;;AAmBA,gBAAsBC,SAAtB;AAAA;AAAA;;;;;2BAAO,iBAAyBC,KAAzB,EAAwChB,IAAxC;AAAA;AAAA;AAAA;AAAA;AAAA;AACCC,YAAAA,IADD,GACQ,mBAAIe,KAAJ,EAAW,CAAX,CADR;AAECC,YAAAA,WAFD,GAEe;AAAEN,cAAAA,IAAI,EAAEV,IAAI,CAACiB,IAAb;AAAmBC,cAAAA,OAAO,EAAElB;AAA5B,aAFf;AAAA;AAAA,mBAIsBF,WAAW,CAACC,IAAD,EAAOiB,WAAP,CAJjC;;AAAA;AAICG,YAAAA,YAJD;AAKCC,YAAAA,GALD,aAKUD,YALV,cAK0BnB,IAAI,CAACiB,IAL/B;AAAA,6CAMEG,GANF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AASP,gBAAsBC,OAAtB;AAAA;AAAA;;;;;2BAAO,kBAAuBC,GAAvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAEoBtC,KAAK,CAACsC,GAAD,EAAM;AAAEC,cAAAA,OAAO,EAAE;AAAX,aAAN,CAFzB;;AAAA;AAEGC,YAAAA,QAFH;;AAAA,kBAGC,CAACA,QAAD,IAAaA,QAAQ,CAACC,MAAT,KAAoB,GAHlC;AAAA;AAAA;AAAA;;AAAA,8CAG8C,KAH9C;;AAAA;AAAA,8CAII,IAJJ;;AAAA;AAAA;AAAA;AAMHhB,YAAAA,OAAO,CAACiB,KAAR,CAAc,aAAMC,OAApB;AANG,8CAOI,KAPJ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAWP,OAAO,SAASC,SAAT,CAAmBC,GAAnB,EAAgC;AACrC,MAAMC,GAAG,GAAGC,QAAQ,CAACC,cAAT,CAAwBC,kBAAxB,EAAZ;AACAH,EAAAA,GAAG,CAACI,IAAJ,CAASC,SAAT,GAAqBN,GAArB;AACA,SAAOC,GAAG,CAACI,IAAJ,CAASE,QAAhB;AACD","sourcesContent":["import axios from 'axios'\r\n\r\nexport function formatBytes(a: number, b: number) {\r\n  if (a === 0) return '0 Bytes'\r\n  const c = 1024\r\n  const d = b || 2\r\n  const e = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']\r\n  const f = Math.floor(Math.log(a) / Math.log(c))\r\n  return parseFloat((a / Math.pow(c, f)).toFixed(d)) + ' ' + e[f]\r\n}\r\n\r\nconst streamFiles = (ipfs: any, file: any) =>\r\n  new Promise((resolve, reject) => {\r\n    const stream = ipfs.addReadableStream({\r\n      wrapWithDirectory: true\r\n      // progress: (length: number) => setFileSizeReceived(formatBytes(length, 0))\r\n    })\r\n\r\n    stream.on('data', (data: any) => {\r\n      console.log(`Added ${data.path} hash: ${data.hash}`)\r\n\r\n      // The last data event will contain the directory hash\r\n      if (data.path === '') resolve(data.hash)\r\n    })\r\n\r\n    stream.on('error', reject)\r\n    stream.write(file)\r\n    stream.end()\r\n  })\r\n\r\nexport async function addToIpfs(files: File[], ipfs: any) {\r\n  const file = [...files][0]\r\n  const fileDetails = { path: file.name, content: file }\r\n\r\n  const directoryCid = await streamFiles(ipfs, fileDetails)\r\n  const cid = `${directoryCid}/${file.name}`\r\n  return cid\r\n}\r\n\r\nexport async function pingUrl(url: string) {\r\n  try {\r\n    const response = await axios(url, { timeout: 5000 })\r\n    if (!response || response.status !== 200) return false\r\n    return true\r\n  } catch (error) {\r\n    console.error(error.message)\r\n    return false\r\n  }\r\n}\r\n\r\nexport function parseHTML(str: string) {\r\n  const tmp = document.implementation.createHTMLDocument()\r\n  tmp.body.innerHTML = str\r\n  return tmp.body.children\r\n}\r\n"]},"metadata":{},"sourceType":"module"}